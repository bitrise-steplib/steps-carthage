package cachedcarthage

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/bitrise-io/go-utils/fileutil"
	"github.com/bitrise-io/go-utils/log"
)

// FileCache ...
type FileCache interface {
	IncludePath(string)
	Commit() error
}

// ProjectStateProvider ...
type ProjectStateProvider interface {
	ParseState(project Project) (ProjectState, error)
}

// Cache can be used the cache Carthage command results.
type Cache struct {
	project       Project
	swiftVersion  string
	filecache     FileCache
	stateProvider ProjectStateProvider
}

// NewCache ...
func NewCache(project Project, swiftVersion string, filecache FileCache, stateProvider ProjectStateProvider) Cache {
	return Cache{
		project:       project,
		swiftVersion:  swiftVersion,
		filecache:     filecache,
		stateProvider: stateProvider,
	}
}

// Create caches the contents of Cartfile.resolved
func (cache Cache) Create() error {
	state, err := cache.stateProvider.ParseState(cache.project)
	if err != nil {
		return err
	}

	if !state.carthageDirExists {
		if err := os.Mkdir(cache.project.carthageDir(), 0777); err != nil {
			return fmt.Errorf("Failed to create dir (%s), error: %s", cache.project.carthageDir(), err)
		}
	}

	cacheContent := cache.createContentOfCacheFile(state.resolvedFileContent)
	if err := fileutil.WriteStringToFile(cache.project.cacheFilePath(), cacheContent); err != nil {
		return fmt.Errorf("Failed to write cahe file, error: %s", err)
	}

	log.Donef("Cachefile created: %s", cache.project.cacheFilePath())
	return nil
}

// Collect loads `fileCache` with the path of carthage directory.
func (cache Cache) Collect() error {
	absCarthageDir, err := filepath.Abs(cache.project.carthageDir())
	if err != nil {
		return fmt.Errorf("failed to determine absolute carthage dir")
	}
	absCacheFilePth, err := filepath.Abs(cache.project.cacheFilePath())
	if err != nil {
		return fmt.Errorf("failed to determine absolute cachefile path")
	}

	cache.filecache.IncludePath(fmt.Sprintf("%s -> %s", absCarthageDir, absCacheFilePth))
	if err := cache.filecache.Commit(); err != nil {
		return fmt.Errorf("failed to commit cache paths")
	}

	return nil
}

// IsAvailable returns if the Carthage project has cache available.
func (cache Cache) IsAvailable() (bool, error) {

	state, err := cache.stateProvider.ParseState(cache.project)
	if err != nil {
		return false, err
	}

	cache.logProjectStateWarnings(state)

	if !state.isCacheIntact() {
		return false, nil
	}

	expectedCacheFileContent := cache.createContentOfCacheFile(state.resolvedFileContent)
	if state.cacheFileContent != expectedCacheFileContent {
		log.Debugf(
			"Cachefile is not valid.\n" +
				"Desired cache content:\n" +
				expectedCacheFileContent +
				"CacheFile content:\n" +
				state.cacheFileContent,
		)

		return false, nil
	}

	return true, nil
}

func (cache Cache) logProjectStateWarnings(state ProjectState) {
	// Print the warning about the missing Cachefile only if the other required file (Cartfile.resolved) is available.
	// If the Cartfile.resolved is not found, then we don't want to mislead the user with this warning.
	if !state.cacheFileExists && state.resolvedFileExists {
		log.Warnf("The " + cacheFileName + " is generated by the step. Probably cache not initialised yet (first cache push initialises the cache), nothing to worry about ;)")

	}

	if !state.resolvedFileExists {
		log.Warnf("No "+resolvedFileName+" found at: %s", cache.project.resolvedFilePath())
		log.Warnf("Make sure it's committed into your repository!")
		log.Warnf(resolvedFileName + " presence ensures that Bitrise will use exactly the same versions of dependencies as you in your local environment. ")
		log.Warnf("The dependencies will not be cached until the " + resolvedFileName + " file presents in the repository.")
	}
}

func (cache Cache) createContentOfCacheFile(resolvedFileContent string) string {
	return fmt.Sprintf("--Swift version: %s --Swift version \n --%s: %s --%s",
		cache.swiftVersion,
		resolvedFileName,
		resolvedFileContent,
		resolvedFileName)
}
